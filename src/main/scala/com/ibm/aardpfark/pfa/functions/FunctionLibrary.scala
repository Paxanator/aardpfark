
// DO NOT EDIT BY HAND, GENERATED BY pfa_dsl_generator.py
// MODIFIED tag is used for edge case modified by hand, please look for the tag before replacing
// Please format using a scala formatter
package com.ibm.aardpfark.pfa.functions

import com.ibm.aardpfark.pfa.expression._
import com.ibm.aardpfark.spark.ml.linear.LinearModelData

trait FunctionLibrary {


  object core {

    object plus {
      def apply(x: Any, y: Any) = new FunctionCall("+", x, y)
    }

    object minus {
      def apply(x: Any, y: Any) = new FunctionCall("-", x, y)
    }

    object mult {
      def apply(x: Any, y: Any) = new FunctionCall("*", x, y)
    }

    object div {
      def apply(x: Any, y: Any) = new FunctionCall("/", x, y)
    }

    object divfloor {
      def apply(x: Any, y: Any) = new FunctionCall("//", x, y)
    }

    object addinv {
      def apply(x: Any) = new FunctionCall("u-", x)
    }

    object mod {
      def apply(k: Any, n: Any) = new FunctionCall("%", k, n)
    }

    object modmod {
      def apply(k: Any, n: Any) = new FunctionCall("%%", k, n)
    }

    object pow {
      def apply(x: Any, y: Any) = new FunctionCall("**", x, y)
    }

    object cmp {
      def apply(x: Any, y: Any) = new FunctionCall("cmp", x, y)
    }

    object eq {
      def apply(x: Any, y: Any) = new FunctionCall("==", x, y)
    }

    object gte {
      def apply(x: Any, y: Any) = new FunctionCall(">=", x, y)
    }

    object gt {
      def apply(x: Any, y: Any) = new FunctionCall(">", x, y)
    }

    object net {
      def apply(x: Any, y: Any) = new FunctionCall("!=", x, y)
    }

    object lt {
      def apply(x: Any, y: Any) = new FunctionCall("<", x, y)
    }

    object lte {
      def apply(x: Any, y: Any) = new FunctionCall("<=", x, y)
    }

    object max {
      def apply(x: Any, y: Any) = new FunctionCall("max", x, y)
    }

    object min {
      def apply(x: Any, y: Any) = new FunctionCall("min", x, y)
    }

    object and {
      def apply(x: Any, y: Any) = new FunctionCall("&&", x, y)
    }

    object || {
      def apply(x: Any, y: Any) = new FunctionCall("||", x, y)
    }

    object xor {
      def apply(x: Any, y: Any) = new FunctionCall("^^", x, y)
    }

    object not {
      def apply(x: Any) = new FunctionCall("!", x)
    }

    object nullableAnd {
      def apply(x: Any, y: Any) = new FunctionCall("&&&", x, y)
    }

    object nullableOr {
      def apply(x: Any, y: Any) = new FunctionCall("|||", x, y)
    }

    object nullableNot {
      def apply(x: Any) = new FunctionCall("!!!", x)
    }

    object & {
      def apply(x: Any, y: Any) = new FunctionCall("&", x, y)
    }

    object | {
      def apply(x: Any, y: Any) = new FunctionCall("|", x, y)
    }

    object ^ {
      def apply(x: Any, y: Any) = new FunctionCall("^", x, y)
    }

    object ~ {
      def apply(x: Any) = new FunctionCall("~", x)
    }

  }


  object m {

    object pi {
      def apply() = new FunctionCall("m.pi")
    }

    object e {
      def apply() = new FunctionCall("m.e")
    }

    object abs {
      def apply(x: Any) = new FunctionCall("m.abs", x)
    }

    object acos {
      def apply(x: Any) = new FunctionCall("m.acos", x)
    }

    object asin {
      def apply(x: Any) = new FunctionCall("m.asin", x)
    }

    object atan {
      def apply(x: Any) = new FunctionCall("m.atan", x)
    }

    object atan2 {
      def apply(y: Any, x: Any) = new FunctionCall("m.atan2", y, x)
    }

    object ceil {
      def apply(x: Any) = new FunctionCall("m.ceil", x)
    }

    object copysign {
      def apply(mag: Any, sign: Any) = new FunctionCall("m.copysign", mag, sign)
    }

    object cos {
      def apply(x: Any) = new FunctionCall("m.cos", x)
    }

    object cosh {
      def apply(x: Any) = new FunctionCall("m.cosh", x)
    }

    object exp {
      def apply(x: Any) = new FunctionCall("m.exp", x)
    }

    object expm1 {
      def apply(x: Any) = new FunctionCall("m.expm1", x)
    }

    object floor {
      def apply(x: Any) = new FunctionCall("m.floor", x)
    }

    object hypot {
      def apply(x: Any, y: Any) = new FunctionCall("m.hypot", x, y)
    }

    object ln {
      def apply(x: Any) = new FunctionCall("m.ln", x)
    }

    object log10 {
      def apply(x: Any) = new FunctionCall("m.log10", x)
    }

    object log {
      def apply(x: Any, base: Any) = new FunctionCall("m.log", x, base)
    }

    object ln1p {
      def apply(x: Any) = new FunctionCall("m.ln1p", x)
    }

    object round {
      def apply(x: Any) = new FunctionCall("m.round", x)
    }

    object rint {
      def apply(x: Any) = new FunctionCall("m.rint", x)
    }

    object signum {
      def apply(x: Any) = new FunctionCall("m.signum", x)
    }

    object sin {
      def apply(x: Any) = new FunctionCall("m.sin", x)
    }

    object sinh {
      def apply(x: Any) = new FunctionCall("m.sinh", x)
    }

    object sqrt {
      def apply(x: Any) = new FunctionCall("m.sqrt", x)
    }

    object tan {
      def apply(x: Any) = new FunctionCall("m.tan", x)
    }

    object tanh {
      def apply(x: Any) = new FunctionCall("m.tanh", x)
    }


    object special {

      object nChooseK {
        def apply(n: Any, k: Any) = new FunctionCall("m.special.nChooseK", n, k)
      }

      object lnBeta {
        def apply(a: Any, b: Any) = new FunctionCall("m.special.lnBeta", a, b)
      }

      object erf {
        def apply(x: Any) = new FunctionCall("m.special.erf", x)
      }

      object erfc {
        def apply(x: Any) = new FunctionCall("m.special.erfc", x)
      }

      object lnGamma {
        def apply(x: Any) = new FunctionCall("m.special.lnGamma", x)
      }

    }


    object link {

      object softmax {
        def apply(x: Any) = new FunctionCall("m.link.softmax", x)
      }

      object logit {
        def apply(x: Any) = new FunctionCall("m.link.logit", x)
      }

      object probit {
        def apply(x: Any) = new FunctionCall("m.link.probit", x)
      }

      object cloglog {
        def apply(x: Any) = new FunctionCall("m.link.cloglog", x)
      }

      object loglog {
        def apply(x: Any) = new FunctionCall("m.link.loglog", x)
      }

      object cauchit {
        def apply(x: Any) = new FunctionCall("m.link.cauchit", x)
      }

      object softplus {
        def apply(x: Any) = new FunctionCall("m.link.softplus", x)
      }

      object relu {
        def apply(x: Any) = new FunctionCall("m.link.relu", x)
      }

      object tanh {
        def apply(x: Any) = new FunctionCall("m.link.tanh", x)
      }

    }


    object kernel {

      object linear {
        def apply(x: Any, y: Any) = new FunctionCall("m.kernel.linear", x, y)
      }

      object rbf {
        def apply(x: Any, y: Any, gamma: Any) = new FunctionCall("m.kernel.rbf", x, y, gamma)
      }

      object poly {
        def apply(x: Any, y: Any, gamma: Any, intercept: Any, degree: Any) = new FunctionCall("m.kernel.poly", x, y, gamma, intercept, degree)
      }

      object sigmoid {
        def apply(x: Any, y: Any, gamma: Any, intercept: Any) = new FunctionCall("m.kernel.sigmoid", x, y, gamma, intercept)
      }

    }


  }


  object la {

    object map {
      def apply(x: Any, fcn: FunctionRef) = new FunctionCall("la.map", x, fcn)
    }

    object scale {
      def apply(x: Any, alpha: Any) = new FunctionCall("la.scale", x, alpha)
    }

    object zipmap {
      def apply(x: Any, y: Any, fcn: Any) = new FunctionCall("la.zipmap", x, y, fcn)
    }

    object add {
      def apply(x: Any, y: Any) = new FunctionCall("la.add", x, y)
    }

    object sub {
      def apply(x: Any, y: Any) = new FunctionCall("la.sub", x, y)
    }

    object dot {
      def apply(x: Any, y: Any) = new FunctionCall("la.dot", x, y)
    }

    object transpose {
      def apply(x: Any) = new FunctionCall("la.transpose", x)
    }

    object inverse {
      def apply(x: Any) = new FunctionCall("la.inverse", x)
    }

    object trace {
      def apply(x: Any) = new FunctionCall("la.trace", x)
    }

    object det {
      def apply(x: Any) = new FunctionCall("la.det", x)
    }

    object symmetric {
      def apply(x: Any, tolerance: Any) = new FunctionCall("la.symmetric", x, tolerance)
    }

    object eigenBasis {
      def apply(x: Any) = new FunctionCall("la.eigenBasis", x)
    }

    object truncate {
      def apply(x: Any, keep: Any) = new FunctionCall("la.truncate", x, keep)
    }

  }


  object metric {

    object simpleEuclidean {
      def apply(x: Any, y: Any) = new FunctionCall("metric.simpleEuclidean", x, y)
    }

    object absDiff {
      def apply(x: Any, y: Any) = new FunctionCall("metric.absDiff", x, y)
    }

    object gaussianSimilarity {
      def apply(x: Any, y: Any, sigma: Any) = new FunctionCall("metric.gaussianSimilarity", x, y, sigma)
    }

    object euclidean {
      def apply(similarity: FunctionRef, x: Any, y: Any) = new FunctionCall("metric.euclidean", similarity, x, y)

      def apply(similarity: FunctionRef, x: Any, y: Any, missingWeight: Any) = new FunctionCall("metric.euclidean", similarity, x, y, missingWeight)
    }

    object squaredEuclidean {
      def apply(similarity: FunctionRef, x: Any, y: Any, missingWeight: Any) = new FunctionCall("metric.squaredEuclidean", similarity, x, y, missingWeight)

      def apply(similarity: FunctionRef, x: Any, y: Any) = new FunctionCall("metric.squaredEuclidean", similarity, x, y)
    }

    object chebyshev {
      def apply(similarity: FunctionRef, x: Any, y: Any, missingWeight: Any) = new FunctionCall("metric.chebyshev", similarity, x, y, missingWeight)

      def apply(similarity: FunctionRef, x: Any, y: Any) = new FunctionCall("metric.chebyshev", similarity, x, y)
    }

    object taxicab {
      def apply(similarity: FunctionRef, x: Any, y: Any) = new FunctionCall("metric.taxicab", similarity, x, y)

      def apply(similarity: FunctionRef, x: Any, y: Any, missingWeight: Any) = new FunctionCall("metric.taxicab", similarity, x, y, missingWeight)
    }

    object minkowski {
      def apply(similarity: FunctionRef, x: Any, y: Any, p: Any, missingWeight: Any) = new FunctionCall("metric.minkowski", similarity, x, y, p, missingWeight)

      def apply(similarity: FunctionRef, x: Any, y: Any, p: Any) = new FunctionCall("metric.minkowski", similarity, x, y, p)
    }

    object simpleMatching {
      def apply(x: Any, y: Any) = new FunctionCall("metric.simpleMatching", x, y)
    }

    object jaccard {
      def apply(x: Any, y: Any) = new FunctionCall("metric.jaccard", x, y)
    }

    object tanimoto {
      def apply(x: Any, y: Any) = new FunctionCall("metric.tanimoto", x, y)
    }

    object binarySimilarity {
      def apply(x: Any, y: Any, c00: Any, c01: Any, c10: Any, c11: Any, d00: Any, d01: Any, d10: Any, d11: Any) = new FunctionCall("metric.binarySimilarity", x, y, c00, c01, c10, c11, d00, d01, d10, d11)
    }

  }


  object rand {

    object int {
      def apply(low: Any, high: Any) = new FunctionCall("rand.int", low, high)

      def apply() = new FunctionCall("rand.int")
    }

    object long {
      def apply(low: Any, high: Any) = new FunctionCall("rand.long", low, high)

      def apply() = new FunctionCall("rand.long")
    }

    object float {
      def apply(low: Any, high: Any) = new FunctionCall("rand.float", low, high)
    }

    object double {
      def apply(low: Any, high: Any) = new FunctionCall("rand.double", low, high)
    }

    object choice {
      def apply(population: Any) = new FunctionCall("rand.choice", population)
    }

    object choices {
      def apply(size: Any, population: Any) = new FunctionCall("rand.choices", size, population)
    }

    object sample {
      def apply(size: Any, population: Any) = new FunctionCall("rand.sample", size, population)
    }

    object histogram {
      def apply(distribution: Any) = new FunctionCall("rand.histogram", distribution)
    }

    object string {
      def apply(size: Any, low: Any, high: Any) = new FunctionCall("rand.string", size, low, high)

      def apply(size: Any) = new FunctionCall("rand.string", size)
      def apply(size: Any, population: Any) = new FunctionCall("rand.string", size, population)
    }

    object bytes {
      def apply(size: Any, low: Any, high: Any) = new FunctionCall("rand.bytes", size, low, high)

      def apply(size: Any, population: Any) = new FunctionCall("rand.bytes", size, population)
      def apply(size: Any) = new FunctionCall("rand.bytes", size)
    }

    object uuid {
      def apply() = new FunctionCall("rand.uuid")
    }

    object uuid4 {
      def apply() = new FunctionCall("rand.uuid4")
    }

    object gaussian {
      def apply(mu: Any, sigma: Any) = new FunctionCall("rand.gaussian", mu, sigma)
    }

  }


  object s {

    object len {
      def apply(s: Any) = new FunctionCall("s.len", s)
    }

    object substr {
      def apply(s: Any, start: Any, end: Any) = new FunctionCall("s.substr", s, start, end)
    }

    object substrto {
      def apply(s: Any, start: Any, end: Any, replacement: Any) = new FunctionCall("s.substrto", s, start, end, replacement)
    }

    object contains {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.contains", haystack, needle)
    }

    object count {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.count", haystack, needle)
    }

    object index {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.index", haystack, needle)
    }

    object rindex {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.rindex", haystack, needle)
    }

    object startswith {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.startswith", haystack, needle)
    }

    object endswith {
      def apply(haystack: Any, needle: Any) = new FunctionCall("s.endswith", haystack, needle)
    }

    object join {
      def apply(array: Any, sep: Any) = new FunctionCall("s.join", array, sep)
    }

    object split {
      def apply(s: Any, sep: Any) = new FunctionCall("s.split", s, sep)
    }

    object hex {
      def apply(x: Any) = new FunctionCall("s.hex", x)

      def apply(x: Any, width: Any, zeroPad: Any) = new FunctionCall("s.hex", x, width, zeroPad)
    }

    object int {
      def apply(x: Any) = new FunctionCall("s.int", x)

      def apply(x: Any, width: Any, zeroPad: Any) = new FunctionCall("s.int", x, width, zeroPad)
    }

    object number {
      def apply(x: Any, width: Any, precision: Any) = new FunctionCall("s.number", x, width, precision)
      //MODIFIED no way to disambiguate between declarations with Any type
      //def apply(x: Any, width: Any, zeroPad: Any) = new FunctionCall("s.number", x, width, zeroPad)
      def apply(x: Any, width: Any, precision: Any, minNoExp: Any, maxNoExp: Any) = new FunctionCall("s.number", x, width, precision, minNoExp, maxNoExp)
      def apply(x: Any) = new FunctionCall("s.number", x)
    }

    object concat {
      def apply(x: Any, y: Any) = new FunctionCall("s.concat", x, y)
    }

    object repeat {
      def apply(s: Any, n: Any) = new FunctionCall("s.repeat", s, n)
    }

    object lower {
      def apply(s: Any) = new FunctionCall("s.lower", s)
    }

    object upper {
      def apply(s: Any) = new FunctionCall("s.upper", s)
    }

    object lstrip {
      def apply(s: Any, chars: Any) = new FunctionCall("s.lstrip", s, chars)
    }

    object rstrip {
      def apply(s: Any, chars: Any) = new FunctionCall("s.rstrip", s, chars)
    }

    object strip {
      def apply(s: Any, chars: Any) = new FunctionCall("s.strip", s, chars)
    }

    object replaceall {
      def apply(s: Any, original: Any, replacement: Any) = new FunctionCall("s.replaceall", s, original, replacement)
    }

    object replacefirst {
      def apply(s: Any, original: Any, replacement: Any) = new FunctionCall("s.replacefirst", s, original, replacement)
    }

    object replacelast {
      def apply(s: Any, original: Any, replacement: Any) = new FunctionCall("s.replacelast", s, original, replacement)
    }

    object translate {
      def apply(s: Any, oldchars: Any, newchars: Any) = new FunctionCall("s.translate", s, oldchars, newchars)
    }

  }


  object re {

    object index {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.index", haystack, pattern)
    }

    object contains {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.contains", haystack, pattern)
    }

    object count {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.count", haystack, pattern)
    }

    object rindex {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.rindex", haystack, pattern)
    }

    object groups {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.groups", haystack, pattern)
    }

    object indexall {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.indexall", haystack, pattern)
    }

    object findall {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.findall", haystack, pattern)
    }

    object findfirst {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.findfirst", haystack, pattern)
    }

    object findgroupsfirst {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.findgroupsfirst", haystack, pattern)
    }

    object findgroupsall {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.findgroupsall", haystack, pattern)
    }

    object groupsall {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.groupsall", haystack, pattern)
    }

    object replacefirst {
      def apply(haystack: Any, pattern: Any, replacement: Any) = new FunctionCall("re.replacefirst", haystack, pattern, replacement)
    }

    object replacelast {
      def apply(haystack: Any, pattern: Any, replacement: Any) = new FunctionCall("re.replacelast", haystack, pattern, replacement)
    }

    object split {
      def apply(haystack: Any, pattern: Any) = new FunctionCall("re.split", haystack, pattern)
    }

    object replaceall {
      def apply(haystack: Any, pattern: Any, replacement: Any) = new FunctionCall("re.replaceall", haystack, pattern, replacement)
    }

  }


  object parse {

    object int {
      def apply(str: Any, base: Any) = new FunctionCall("parse.int", str, base)
    }

    object long {
      def apply(str: Any, base: Any) = new FunctionCall("parse.long", str, base)
    }

    object float {
      def apply(str: Any) = new FunctionCall("parse.float", str)
    }

    object double {
      def apply(str: Any) = new FunctionCall("parse.double", str)
    }

  }


  object cast {

    object signed {
      def apply(x: Any, bits: Any) = new FunctionCall("cast.signed", x, bits)
    }

    object unsigned {
      def apply(x: Any, bits: Any) = new FunctionCall("cast.unsigned", x, bits)
    }

    object int {
      def apply(x: Any) = new FunctionCall("cast.int", x)
    }

    object long {
      def apply(x: Any) = new FunctionCall("cast.long", x)
    }

    object float {
      def apply(x: Any) = new FunctionCall("cast.float", x)
    }

    object double {
      def apply(x: Any) = new FunctionCall("cast.double", x)
    }

    object fanoutBoolean {
      def apply(x: Any, minimum: Any, maximum: Any, outOfRange: Any) = new FunctionCall("cast.fanoutBoolean", x, minimum, maximum, outOfRange)

      def apply(x: Any) = new FunctionCall("cast.fanoutBoolean", x)
      def apply(x: Any, dictionary: Any, outOfRange: Any) = new FunctionCall("cast.fanoutBoolean", x, dictionary, outOfRange)
    }

    object fanoutInt {
      def apply(x: Any) = new FunctionCall("cast.fanoutInt", x)

      def apply(x: Any, dictionary: Any, outOfRange: Any) = new FunctionCall("cast.fanoutInt", x, dictionary, outOfRange)
      def apply(x: Any, minimum: Any, maximum: Any, outOfRange: Any) = new FunctionCall("cast.fanoutInt", x, minimum, maximum, outOfRange)
    }

    object fanoutLong {
      def apply(x: Any, dictionary: Any, outOfRange: Any) = new FunctionCall("cast.fanoutLong", x, dictionary, outOfRange)

      def apply(x: Any) = new FunctionCall("cast.fanoutLong", x)
      def apply(x: Any, minimum: Any, maximum: Any, outOfRange: Any) = new FunctionCall("cast.fanoutLong", x, minimum, maximum, outOfRange)
    }

    object fanoutFloat {
      def apply(x: Any, minimum: Any, maximum: Any, outOfRange: Any) = new FunctionCall("cast.fanoutFloat", x, minimum, maximum, outOfRange)

      def apply(x: Any, dictionary: Any, outOfRange: Any) = new FunctionCall("cast.fanoutFloat", x, dictionary, outOfRange)
      def apply(x: Any) = new FunctionCall("cast.fanoutFloat", x)
    }

    object fanoutDouble {
      def apply(x: Any, minimum: Any, maximum: Any, outOfRange: Any) = new FunctionCall("cast.fanoutDouble", x, minimum, maximum, outOfRange)

      def apply(x: Any) = new FunctionCall("cast.fanoutDouble", x)
      def apply(x: Any, dictionary: Any, outOfRange: Any) = new FunctionCall("cast.fanoutDouble", x, dictionary, outOfRange)
    }

    object avro {
      def apply(x: Any) = new FunctionCall("cast.avro", x)
    }

    object json {
      def apply(x: Any) = new FunctionCall("cast.json", x)
    }

  }


  object a {

    object len {
      def apply(a: Any) = new FunctionCall("a.len", a)
    }

    object subseq {
      def apply(a: Any, start: Any, end: Any) = new FunctionCall("a.subseq", a, start, end)
    }

    object head {
      def apply(a: Any) = new FunctionCall("a.head", a)
    }

    object tail {
      def apply(a: Any) = new FunctionCall("a.tail", a)
    }

    object last {
      def apply(a: Any) = new FunctionCall("a.last", a)
    }

    object init {
      def apply(a: Any) = new FunctionCall("a.init", a)
    }

    object subseqto {
      def apply(a: Any, start: Any, end: Any, replacement: Any) = new FunctionCall("a.subseqto", a, start, end, replacement)
    }

    object contains {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.contains", haystack, needle)

      def apply(haystack: Any, needle: FunctionRef) = new FunctionCall("a.contains", haystack, needle)
    }

    object count {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.count", haystack, needle)

      def apply(haystack: Any, needle: FunctionRef) = new FunctionCall("a.count", haystack, needle)
    }

    object index {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.index", haystack, needle)

      def apply(haystack: Any, needle: FunctionRef) = new FunctionCall("a.index", haystack, needle)
    }

    object rindex {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.rindex", haystack, needle)

      def apply(haystack: Any, needle: FunctionRef) = new FunctionCall("a.rindex", haystack, needle)
    }

    object startswith {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.startswith", haystack, needle)
    }

    object endswith {
      def apply(haystack: Any, needle: Any) = new FunctionCall("a.endswith", haystack, needle)
    }

    object concat {
      def apply(a: Any, b: Any) = new FunctionCall("a.concat", a, b)
    }

    object append {
      def apply(a: Any, item: Any) = new FunctionCall("a.append", a, item)
    }

    object cycle {
      def apply(a: Any, item: Any, maxLength: Any) = new FunctionCall("a.cycle", a, item, maxLength)
    }

    object insert {
      def apply(a: Any, index: Any, item: Any) = new FunctionCall("a.insert", a, index, item)
    }

    object replace {
      def apply(a: Any, index: Any, item: Any) = new FunctionCall("a.replace", a, index, item)
    }

    object remove {
      def apply(a: Any, start: Any, end: Any) = new FunctionCall("a.remove", a, start, end)

      def apply(a: Any, index: Any) = new FunctionCall("a.remove", a, index)
    }

    object rotate {
      def apply(a: Any, steps: Any) = new FunctionCall("a.rotate", a, steps)
    }

    object sort {
      def apply(a: Any) = new FunctionCall("a.sort", a)
    }

    object sortLT {
      def apply(a: Any, lessThan: FunctionRef) = new FunctionCall("a.sortLT", a, lessThan)
    }

    object shuffle {
      def apply(a: Any) = new FunctionCall("a.shuffle", a)
    }

    object reverse {
      def apply(a: Any) = new FunctionCall("a.reverse", a)
    }

    object max {
      def apply(a: Any) = new FunctionCall("a.max", a)
    }

    object min {
      def apply(a: Any) = new FunctionCall("a.min", a)
    }

    object maxLT {
      def apply(a: Any, lessThan: FunctionRef) = new FunctionCall("a.maxLT", a, lessThan)
    }

    object minLT {
      def apply(a: Any, lessThan: FunctionRef) = new FunctionCall("a.minLT", a, lessThan)
    }

    object maxN {
      def apply(a: Any, n: Any) = new FunctionCall("a.maxN", a, n)
    }

    object minN {
      def apply(a: Any, n: Any) = new FunctionCall("a.minN", a, n)
    }

    object maxNLT {
      def apply(a: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("a.maxNLT", a, n, lessThan)
    }

    object minNLT {
      def apply(a: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("a.minNLT", a, n, lessThan)
    }

    object argmax {
      def apply(a: Any) = new FunctionCall("a.argmax", a)
    }

    object argmin {
      def apply(a: Any) = new FunctionCall("a.argmin", a)
    }

    object argmaxLT {
      def apply(a: Any, lessThan: FunctionRef) = new FunctionCall("a.argmaxLT", a, lessThan)
    }

    object argminLT {
      def apply(a: Any, lessThan: FunctionRef) = new FunctionCall("a.argminLT", a, lessThan)
    }

    object argmaxN {
      def apply(a: Any, n: Any) = new FunctionCall("a.argmaxN", a, n)
    }

    object argminN {
      def apply(a: Any, n: Any) = new FunctionCall("a.argminN", a, n)
    }

    object argmaxNLT {
      def apply(a: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("a.argmaxNLT", a, n, lessThan)
    }

    object argminNLT {
      def apply(a: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("a.argminNLT", a, n, lessThan)
    }

    object sum {
      def apply(a: Any) = new FunctionCall("a.sum", a)
    }

    object product {
      def apply(a: Any) = new FunctionCall("a.product", a)
    }

    object lnsum {
      def apply(a: Any) = new FunctionCall("a.lnsum", a)
    }

    object mean {
      def apply(a: Any) = new FunctionCall("a.mean", a)
    }

    object geomean {
      def apply(a: Any) = new FunctionCall("a.geomean", a)
    }

    object median {
      def apply(a: Any) = new FunctionCall("a.median", a)
    }

    object ntile {
      def apply(a: Any, p: Any) = new FunctionCall("a.ntile", a, p)
    }

    object mode {
      def apply(a: Any) = new FunctionCall("a.mode", a)
    }

    object logsumexp {
      def apply(a: Any) = new FunctionCall("a.logsumexp", a)
    }

    object distinct {
      def apply(a: Any) = new FunctionCall("a.distinct", a)
    }

    object seteq {
      def apply(a: Any, b: Any) = new FunctionCall("a.seteq", a, b)
    }

    object union {
      def apply(a: Any, b: Any) = new FunctionCall("a.union", a, b)
    }

    object intersection {
      def apply(a: Any, b: Any) = new FunctionCall("a.intersection", a, b)
    }

    object diff {
      def apply(a: Any, b: Any) = new FunctionCall("a.diff", a, b)
    }

    object symdiff {
      def apply(a: Any, b: Any) = new FunctionCall("a.symdiff", a, b)
    }

    object subset {
      def apply(little: Any, big: Any) = new FunctionCall("a.subset", little, big)
    }

    object disjoint {
      def apply(a: Any, b: Any) = new FunctionCall("a.disjoint", a, b)
    }

    object map {
      //MODIFIED fcn to Any to conform to existing FunctionDef vs. FunctionRef
      def apply(a: Any, fcn: Any) = new FunctionCall("a.map", a, fcn)
    }

    object mapWithIndex {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.mapWithIndex", a, fcn)
    }

    object filter {
      //MODIFIED fcn to Any to conform to existing FunctionDef vs. FunctionRef
      def apply(a: Any, fcn: Any) = new FunctionCall("a.filter", a, fcn)
    }

    object filterWithIndex {
      //MODIFIED fcn to Any to conform to existing FunctionDef vs. FunctionRef
      def apply(a: Any, fcn: Any) = new FunctionCall("a.filterWithIndex", a, fcn)
    }

    object filterMap {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.filterMap", a, fcn)
    }

    object filterMapWithIndex {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.filterMapWithIndex", a, fcn)
    }

    object flatMap {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.flatMap", a, fcn)
    }

    object flatMapWithIndex {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.flatMapWithIndex", a, fcn)
    }

    object zipmap {
      //MODIFIED fcn to Any to conform to existing FunctionDef vs. FunctionRef
      def apply(a: Any, b: Any, c: Any, d: Any, fcn: Any) = new FunctionCall("a.zipmap", a, b, c, d, fcn)

      def apply(a: Any, b: Any, fcn: Any) = new FunctionCall("a.zipmap", a, b, fcn)
      def apply(a: Any, b: Any, c: Any, fcn: Any) = new FunctionCall("a.zipmap", a, b, c, fcn)
    }

    object zipmapWithIndex {
      def apply(a: Any, b: Any, c: Any, d: Any, fcn: FunctionRef) = new FunctionCall("a.zipmapWithIndex", a, b, c, d, fcn)

      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("a.zipmapWithIndex", a, b, fcn)
      def apply(a: Any, b: Any, c: Any, fcn: FunctionRef) = new FunctionCall("a.zipmapWithIndex", a, b, c, fcn)
    }

    object reduce {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.reduce", a, fcn)
    }

    object reduceRight {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.reduceRight", a, fcn)
    }

    object fold {
      def apply(a: Any, zero: Any, fcn: FunctionRef) = new FunctionCall("a.fold", a, zero, fcn)
    }

    object foldRight {
      def apply(a: Any, zero: Any, fcn: FunctionRef) = new FunctionCall("a.foldRight", a, zero, fcn)
    }

    object takeWhile {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.takeWhile", a, fcn)
    }

    object dropWhile {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.dropWhile", a, fcn)
    }

    object any {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.any", a, fcn)
    }

    object all {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.all", a, fcn)
    }

    object corresponds {
      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("a.corresponds", a, b, fcn)
    }

    object correspondsWithIndex {
      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("a.correspondsWithIndex", a, b, fcn)
    }

    object slidingWindow {
      def apply(a: Any, size: Any, step: Any) = new FunctionCall("a.slidingWindow", a, size, step)
    }

    object combinations {
      def apply(a: Any, size: Any) = new FunctionCall("a.combinations", a, size)
    }

    object permutations {
      def apply(a: Any) = new FunctionCall("a.permutations", a)
    }

    object flatten {
      def apply(a: Any) = new FunctionCall("a.flatten", a)
    }

    object groupby {
      def apply(a: Any, fcn: FunctionRef) = new FunctionCall("a.groupby", a, fcn)
    }

  }


  object map {

    object len {
      def apply(m: Any) = new FunctionCall("map.len", m)
    }

    object keys {
      def apply(m: Any) = new FunctionCall("map.keys", m)
    }

    object values {
      def apply(m: Any) = new FunctionCall("map.values", m)
    }

    object containsKey {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.containsKey", m, fcn)

      def apply(m: Any, key: Any) = new FunctionCall("map.containsKey", m, key)
    }

    object containsValue {
      def apply(m: Any, value: Any) = new FunctionCall("map.containsValue", m, value)

      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.containsValue", m, fcn)
    }

    object add {
      def apply(m: Any, item: Any) = new FunctionCall("map.add", m, item)

      def apply(m: Any, key: Any, value: Any) = new FunctionCall("map.add", m, key, value)
    }

    object remove {
      def apply(m: Any, key: Any) = new FunctionCall("map.remove", m, key)
    }

    object only {
      def apply(m: Any, keys: Any) = new FunctionCall("map.only", m, keys)
    }

    object except {
      def apply(m: Any, keys: Any) = new FunctionCall("map.except", m, keys)
    }

    object update {
      def apply(base: Any, overlay: Any) = new FunctionCall("map.update", base, overlay)
    }

    object split {
      def apply(m: Any) = new FunctionCall("map.split", m)
    }

    object join {
      def apply(a: Any) = new FunctionCall("map.join", a)
    }

    object argmax {
      def apply(m: Any) = new FunctionCall("map.argmax", m)
    }

    object argmin {
      def apply(m: Any) = new FunctionCall("map.argmin", m)
    }

    object argmaxLT {
      def apply(m: Any, lessThan: FunctionRef) = new FunctionCall("map.argmaxLT", m, lessThan)
    }

    object argminLT {
      def apply(m: Any, lessThan: FunctionRef) = new FunctionCall("map.argminLT", m, lessThan)
    }

    object argmaxN {
      def apply(m: Any, n: Any) = new FunctionCall("map.argmaxN", m, n)
    }

    object argminN {
      def apply(m: Any, n: Any) = new FunctionCall("map.argminN", m, n)
    }

    object argmaxNLT {
      def apply(m: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("map.argmaxNLT", m, n, lessThan)
    }

    object argminNLT {
      def apply(m: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("map.argminNLT", m, n, lessThan)
    }

    object toset {
      def apply(a: Any) = new FunctionCall("map.toset", a)
    }

    object fromset {
      def apply(s: Any) = new FunctionCall("map.fromset", s)
    }

    object in {
      def apply(s: Any, x: Any) = new FunctionCall("map.in", s, x)
    }

    object union {
      def apply(a: Any, b: Any) = new FunctionCall("map.union", a, b)
    }

    object intersection {
      def apply(a: Any, b: Any) = new FunctionCall("map.intersection", a, b)
    }

    object diff {
      def apply(a: Any, b: Any) = new FunctionCall("map.diff", a, b)
    }

    object symdiff {
      def apply(a: Any, b: Any) = new FunctionCall("map.symdiff", a, b)
    }

    object subset {
      def apply(little: Any, big: Any) = new FunctionCall("map.subset", little, big)
    }

    object disjoint {
      def apply(a: Any, b: Any) = new FunctionCall("map.disjoint", a, b)
    }

    object map {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.map", m, fcn)
    }

    object mapWithKey {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.mapWithKey", m, fcn)
    }

    object filter {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.filter", m, fcn)
    }

    object filterWithKey {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.filterWithKey", m, fcn)
    }

    object filterMap {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.filterMap", m, fcn)
    }

    object filterMapWithKey {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.filterMapWithKey", m, fcn)
    }

    object flatMap {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.flatMap", m, fcn)
    }

    object flatMapWithKey {
      def apply(m: Any, fcn: FunctionRef) = new FunctionCall("map.flatMapWithKey", m, fcn)
    }

    object zipmap {
      //MODIFIED fcn to Any to conform to existing FunctionDef vs. FunctionRef
      def apply(a: Any, b: Any, c: Any, fcn: Any) = new FunctionCall("map.zipmap", a, b, c, fcn)

      def apply(a: Any, b: Any, fcn: Any) = new FunctionCall("map.zipmap", a, b, fcn)
      def apply(a: Any, b: Any, c: Any, d: Any, fcn: Any) = new FunctionCall("map.zipmap", a, b, c, d, fcn)
    }

    object zipmapWithKey {
      def apply(a: Any, b: Any, c: Any, d: Any, fcn: FunctionRef) = new FunctionCall("map.zipmapWithKey", a, b, c, d, fcn)

      def apply(a: Any, b: Any, c: Any, fcn: FunctionRef) = new FunctionCall("map.zipmapWithKey", a, b, c, fcn)
      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("map.zipmapWithKey", a, b, fcn)
    }

    object corresponds {
      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("map.corresponds", a, b, fcn)
    }

    object correspondsWithKey {
      def apply(a: Any, b: Any, fcn: FunctionRef) = new FunctionCall("map.correspondsWithKey", a, b, fcn)
    }

  }


  object bytes {

    object len {
      def apply(x: Any) = new FunctionCall("bytes.len", x)
    }

    object subseq {
      def apply(x: Any, start: Any, end: Any) = new FunctionCall("bytes.subseq", x, start, end)
    }

    object subseqto {
      def apply(x: Any, start: Any, end: Any, replacement: Any) = new FunctionCall("bytes.subseqto", x, start, end, replacement)
    }

    object isAscii {
      def apply(x: Any) = new FunctionCall("bytes.isAscii", x)
    }

    object isLatin1 {
      def apply(x: Any) = new FunctionCall("bytes.isLatin1", x)
    }

    object isUtf8 {
      def apply(x: Any) = new FunctionCall("bytes.isUtf8", x)
    }

    object isUtf16 {
      def apply(x: Any) = new FunctionCall("bytes.isUtf16", x)
    }

    object isUtf16be {
      def apply(x: Any) = new FunctionCall("bytes.isUtf16be", x)
    }

    object isUtf16le {
      def apply(x: Any) = new FunctionCall("bytes.isUtf16le", x)
    }

    object decodeAscii {
      def apply(x: Any) = new FunctionCall("bytes.decodeAscii", x)
    }

    object decodeLatin1 {
      def apply(x: Any) = new FunctionCall("bytes.decodeLatin1", x)
    }

    object decodeUtf8 {
      def apply(x: Any) = new FunctionCall("bytes.decodeUtf8", x)
    }

    object decodeUtf16 {
      def apply(x: Any) = new FunctionCall("bytes.decodeUtf16", x)
    }

    object decodeUtf16be {
      def apply(x: Any) = new FunctionCall("bytes.decodeUtf16be", x)
    }

    object decodeUtf16le {
      def apply(x: Any) = new FunctionCall("bytes.decodeUtf16le", x)
    }

    object encodeAscii {
      def apply(s: Any) = new FunctionCall("bytes.encodeAscii", s)
    }

    object encodeLatin1 {
      def apply(s: Any) = new FunctionCall("bytes.encodeLatin1", s)
    }

    object encodeUtf8 {
      def apply(s: Any) = new FunctionCall("bytes.encodeUtf8", s)
    }

    object encodeUtf16 {
      def apply(s: Any) = new FunctionCall("bytes.encodeUtf16", s)
    }

    object encodeUtf16be {
      def apply(s: Any) = new FunctionCall("bytes.encodeUtf16be", s)
    }

    object encodeUtf16le {
      def apply(s: Any) = new FunctionCall("bytes.encodeUtf16le", s)
    }

    object toBase64 {
      def apply(x: Any) = new FunctionCall("bytes.toBase64", x)
    }

    object fromBase64 {
      def apply(s: Any) = new FunctionCall("bytes.fromBase64", s)
    }

  }


  object fixed {

    object toBytes {
      def apply(x: Any) = new FunctionCall("fixed.toBytes", x)
    }

    object fromBytes {
      def apply(original: Any, replacement: Any) = new FunctionCall("fixed.fromBytes", original, replacement)
    }

  }


  object enum {

    object toStringPFA {
      def apply(x: Any) = new FunctionCall("enum.toString", x)
    }

    object toInt {
      def apply(x: Any) = new FunctionCall("enum.toInt", x)
    }

    object numSymbols {
      def apply(x: Any) = new FunctionCall("enum.numSymbols", x)
    }

  }


  object time {

    object year {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.year", ts, zone)
    }

    object monthOfYear {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.monthOfYear", ts, zone)
    }

    object dayOfYear {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.dayOfYear", ts, zone)
    }

    object dayOfMonth {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.dayOfMonth", ts, zone)
    }

    object dayOfWeek {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.dayOfWeek", ts, zone)
    }

    object hourOfDay {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.hourOfDay", ts, zone)
    }

    object minuteOfHour {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.minuteOfHour", ts, zone)
    }

    object secondOfMinute {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.secondOfMinute", ts, zone)
    }

    object makeTimestamp {
      def apply(year: Any, month: Any, day: Any, hour: Any, minute: Any, second: Any, millisecond: Any, zone: Any) = new FunctionCall("time.makeTimestamp", year, month, day, hour, minute, second, millisecond, zone)
    }

    object isSecondOfMinute {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isSecondOfMinute", ts, zone, low, high)
    }

    object isMinuteOfHour {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isMinuteOfHour", ts, zone, low, high)
    }

    object isHourOfDay {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isHourOfDay", ts, zone, low, high)
    }

    object isDayOfWeek {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isDayOfWeek", ts, zone, low, high)
    }

    object isDayOfMonth {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isDayOfMonth", ts, zone, low, high)
    }

    object isMonthOfYear {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isMonthOfYear", ts, zone, low, high)
    }

    object isDayOfYear {
      def apply(ts: Any, zone: Any, low: Any, high: Any) = new FunctionCall("time.isDayOfYear", ts, zone, low, high)
    }

    object isWeekend {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.isWeekend", ts, zone)
    }

    object isWorkHours {
      def apply(ts: Any, zone: Any) = new FunctionCall("time.isWorkHours", ts, zone)
    }

  }


  object impute {

    object errorOnNull {
      def apply(x: Any) = new FunctionCall("impute.errorOnNull", x)
    }

    object defaultOnNull {
      def apply(x: Any, default: Any) = new FunctionCall("impute.defaultOnNull", x, default)
    }

    object isnan {
      def apply(x: Any) = new FunctionCall("impute.isnan", x)
    }

    object isinf {
      def apply(x: Any) = new FunctionCall("impute.isinf", x)
    }

    object isnum {
      def apply(x: Any) = new FunctionCall("impute.isnum", x)
    }

    object errorOnNonNum {
      def apply(x: Any) = new FunctionCall("impute.errorOnNonNum", x)
    }

    object defaultOnNonNum {
      def apply(x: Any, default: Any) = new FunctionCall("impute.defaultOnNonNum", x, default)
    }

  }


  object interp {

    object bin {
      def apply(x: Any, numbins: Any, low: Any, high: Any) = new FunctionCall("interp.bin", x, numbins, low, high)

      def apply(x: Any, origin: Any, width: Any) = new FunctionCall("interp.bin", x, origin, width)
    }

    object nearest {
      def apply(x: Any, table: Any) = new FunctionCall("interp.nearest", x, table)

      def apply(x: Any, table: Any, metric: FunctionRef) = new FunctionCall("interp.nearest", x, table, metric)
    }

    object linear {
      def apply(x: Any, table: Any) = new FunctionCall("interp.linear", x, table)
    }

    object linearFlat {
      def apply(x: Any, table: Any) = new FunctionCall("interp.linearFlat", x, table)
    }

    object linearMissing {
      def apply(x: Any, table: Any) = new FunctionCall("interp.linearMissing", x, table)
    }

  }


  object prob {


    object dist {

      object gaussianLL {
        def apply(x: Any, mu: Any, sigma: Any) = new FunctionCall("prob.dist.gaussianLL", x, mu, sigma)

        def apply(x: Any, params: Any) = new FunctionCall("prob.dist.gaussianLL", x, params)
      }

      object gaussianCDF {
        def apply(x: Any, mu: Any, sigma: Any) = new FunctionCall("prob.dist.gaussianCDF", x, mu, sigma)

        def apply(x: Any, params: Any) = new FunctionCall("prob.dist.gaussianCDF", x, params)
      }

      object gaussianQF {
        def apply(p: Any, mu: Any, sigma: Any) = new FunctionCall("prob.dist.gaussianQF", p, mu, sigma)

        def apply(p: Any, params: Any) = new FunctionCall("prob.dist.gaussianQF", p, params)
      }

      object exponentialPDF {
        def apply(x: Any, lambda: Any) = new FunctionCall("prob.dist.exponentialPDF", x, lambda)
      }

      object exponentialCDF {
        def apply(x: Any, lambda: Any) = new FunctionCall("prob.dist.exponentialCDF", x, lambda)
      }

      object exponentialQF {
        def apply(p: Any, lambda: Any) = new FunctionCall("prob.dist.exponentialQF", p, lambda)
      }

      object chi2PDF {
        def apply(x: Any, dof: Any) = new FunctionCall("prob.dist.chi2PDF", x, dof)
      }

      object chi2CDF {
        def apply(x: Any, dof: Any) = new FunctionCall("prob.dist.chi2CDF", x, dof)
      }

      object chi2QF {
        def apply(p: Any, dof: Any) = new FunctionCall("prob.dist.chi2QF", p, dof)
      }

      object poissonPDF {
        def apply(x: Any, lambda: Any) = new FunctionCall("prob.dist.poissonPDF", x, lambda)
      }

      object poissonCDF {
        def apply(x: Any, lambda: Any) = new FunctionCall("prob.dist.poissonCDF", x, lambda)
      }

      object poissonQF {
        def apply(p: Any, lambda: Any) = new FunctionCall("prob.dist.poissonQF", p, lambda)
      }

      object gammaPDF {
        def apply(x: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.gammaPDF", x, shape, scale)
      }

      object gammaCDF {
        def apply(x: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.gammaCDF", x, shape, scale)
      }

      object gammaQF {
        def apply(p: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.gammaQF", p, shape, scale)
      }

      object betaPDF {
        def apply(x: Any, a: Any, b: Any) = new FunctionCall("prob.dist.betaPDF", x, a, b)
      }

      object betaCDF {
        def apply(x: Any, a: Any, b: Any) = new FunctionCall("prob.dist.betaCDF", x, a, b)
      }

      object betaQF {
        def apply(p: Any, a: Any, b: Any) = new FunctionCall("prob.dist.betaQF", p, a, b)
      }

      object cauchyPDF {
        def apply(x: Any, location: Any, scale: Any) = new FunctionCall("prob.dist.cauchyPDF", x, location, scale)
      }

      object cauchyCDF {
        def apply(x: Any, location: Any, scale: Any) = new FunctionCall("prob.dist.cauchyCDF", x, location, scale)
      }

      object cauchyQF {
        def apply(p: Any, location: Any, scale: Any) = new FunctionCall("prob.dist.cauchyQF", p, location, scale)
      }

      object fPDF {
        def apply(x: Any, d1: Any, d2: Any) = new FunctionCall("prob.dist.fPDF", x, d1, d2)
      }

      object fCDF {
        def apply(x: Any, d1: Any, d2: Any) = new FunctionCall("prob.dist.fCDF", x, d1, d2)
      }

      object fQF {
        def apply(p: Any, d1: Any, d2: Any) = new FunctionCall("prob.dist.fQF", p, d1, d2)
      }

      object lognormalPDF {
        def apply(x: Any, meanlog: Any, sdlog: Any) = new FunctionCall("prob.dist.lognormalPDF", x, meanlog, sdlog)
      }

      object lognormalCDF {
        def apply(x: Any, meanlog: Any, sdlog: Any) = new FunctionCall("prob.dist.lognormalCDF", x, meanlog, sdlog)
      }

      object lognormalQF {
        def apply(p: Any, meanlog: Any, sdlog: Any) = new FunctionCall("prob.dist.lognormalQF", p, meanlog, sdlog)
      }

      object tPDF {
        def apply(x: Any, dof: Any) = new FunctionCall("prob.dist.tPDF", x, dof)
      }

      object tCDF {
        def apply(x: Any, dof: Any) = new FunctionCall("prob.dist.tCDF", x, dof)
      }

      object tQF {
        def apply(p: Any, dof: Any) = new FunctionCall("prob.dist.tQF", p, dof)
      }

      object binomialPDF {
        def apply(x: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.binomialPDF", x, size, prob)
      }

      object binomialCDF {
        def apply(x: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.binomialCDF", x, size, prob)
      }

      object binomialQF {
        def apply(p: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.binomialQF", p, size, prob)
      }

      object uniformPDF {
        def apply(x: Any, min: Any, max: Any) = new FunctionCall("prob.dist.uniformPDF", x, min, max)
      }

      object uniformCDF {
        def apply(x: Any, min: Any, max: Any) = new FunctionCall("prob.dist.uniformCDF", x, min, max)
      }

      object uniformQF {
        def apply(p: Any, min: Any, max: Any) = new FunctionCall("prob.dist.uniformQF", p, min, max)
      }

      object geometricPDF {
        def apply(x: Any, prob: Any) = new FunctionCall("prob.dist.geometricPDF", x, prob)
      }

      object geometricCDF {
        def apply(x: Any, prob: Any) = new FunctionCall("prob.dist.geometricCDF", x, prob)
      }

      object geometricQF {
        def apply(p: Any, prob: Any) = new FunctionCall("prob.dist.geometricQF", p, prob)
      }

      object hypergeometricPDF {
        def apply(x: Any, m: Any, n: Any, k: Any) = new FunctionCall("prob.dist.hypergeometricPDF", x, m, n, k)
      }

      object hypergeometricCDF {
        def apply(x: Any, m: Any, n: Any, k: Any) = new FunctionCall("prob.dist.hypergeometricCDF", x, m, n, k)
      }

      object hypergeometricQF {
        def apply(p: Any, m: Any, n: Any, k: Any) = new FunctionCall("prob.dist.hypergeometricQF", p, m, n, k)
      }

      object weibullPDF {
        def apply(x: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.weibullPDF", x, shape, scale)
      }

      object weibullCDF {
        def apply(x: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.weibullCDF", x, shape, scale)
      }

      object weibullQF {
        def apply(p: Any, shape: Any, scale: Any) = new FunctionCall("prob.dist.weibullQF", p, shape, scale)
      }

      object negativeBinomialPDF {
        def apply(x: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.negativeBinomialPDF", x, size, prob)
      }

      object negativeBinomialCDF {
        def apply(x: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.negativeBinomialCDF", x, size, prob)
      }

      object negativeBinomialQF {
        def apply(p: Any, size: Any, prob: Any) = new FunctionCall("prob.dist.negativeBinomialQF", p, size, prob)
      }

    }


  }


  object stat {


    object test {

      object kolmogorov {
        def apply(x: Any, y: Any) = new FunctionCall("stat.test.kolmogorov", x, y)
      }

      object residual {
        def apply(observation: Any, prediciton: Any) = new FunctionCall("stat.test.residual", observation, prediciton)
      }

      object pull {
        def apply(observation: Any, prediciton: Any, uncertainty: Any) = new FunctionCall("stat.test.pull", observation, prediciton, uncertainty)
      }

      object mahalanobis {
        def apply(observation: Any, prediction: Any, covariance: Any) = new FunctionCall("stat.test.mahalanobis", observation, prediction, covariance)
      }

      object updateChi2 {
        def apply(pull: Any, state: Any) = new FunctionCall("stat.test.updateChi2", pull, state)
      }

      object reducedChi2 {
        def apply(state: Any) = new FunctionCall("stat.test.reducedChi2", state)
      }

      object chi2Prob {
        def apply(state: Any) = new FunctionCall("stat.test.chi2Prob", state)
      }

    }


    object sample {

      object update {
        def apply(x: Any, w: Any, state: Any) = new FunctionCall("stat.sample.update", x, w, state)
      }

      object updateCovariance {
        def apply(x: Any, w: Any, state: Any) = new FunctionCall("stat.sample.updateCovariance", x, w, state)
      }

      object updateWindow {
        def apply(x: Any, w: Any, state: Any, windowSize: Any) = new FunctionCall("stat.sample.updateWindow", x, w, state, windowSize)
      }

      object updateEWMA {
        def apply(x: Any, alpha: Any, state: Any) = new FunctionCall("stat.sample.updateEWMA", x, alpha, state)
      }

      object updateHoltWinters {
        def apply(x: Any, alpha: Any, beta: Any, state: Any) = new FunctionCall("stat.sample.updateHoltWinters", x, alpha, beta, state)
      }

      object updateHoltWintersPeriodic {
        def apply(x: Any, alpha: Any, beta: Any, gamma: Any, state: Any) = new FunctionCall("stat.sample.updateHoltWintersPeriodic", x, alpha, beta, gamma, state)
      }

      object forecast1HoltWinters {
        def apply(state: Any) = new FunctionCall("stat.sample.forecast1HoltWinters", state)
      }

      object forecastHoltWinters {
        def apply(n: Any, state: Any) = new FunctionCall("stat.sample.forecastHoltWinters", n, state)
      }

      object fillHistogram {
        def apply(x: Any, w: Any, histogram: Any) = new FunctionCall("stat.sample.fillHistogram", x, w, histogram)
      }

      object fillHistogram2d {
        def apply(x: Any, y: Any, w: Any, histogram: Any) = new FunctionCall("stat.sample.fillHistogram2d", x, y, w, histogram)
      }

      object fillCounter {
        def apply(x: Any, w: Any, counter: Any) = new FunctionCall("stat.sample.fillCounter", x, w, counter)
      }

      object topN {
        def apply(x: Any, top: Any, n: Any, lessThan: FunctionRef) = new FunctionCall("stat.sample.topN", x, top, n, lessThan)
      }

    }


    object change {

      object updateTrigger {
        def apply(predicate: Any, history: Any) = new FunctionCall("stat.change.updateTrigger", predicate, history)
      }

      object zValue {
        def apply(x: Any, meanVariance: Any, unbiased: Any) = new FunctionCall("stat.change.zValue", x, meanVariance, unbiased)

        def apply(x: Any, meanVariance: Any) = new FunctionCall("stat.change.zValue", x, meanVariance)
      }

      object updateCUSUM {
        def apply(logLikelihoodRatio: Any, last: Any, reset: Any) = new FunctionCall("stat.change.updateCUSUM", logLikelihoodRatio, last, reset)
      }

    }


  }


  object model {


    object reg {

      object linear {
        def apply(datum: Any, model: Any) = new FunctionCall("model.reg.linear", datum, model)
      }

      object linearVariance {
        def apply(datum: Any, model: Any) = new FunctionCall("model.reg.linearVariance", datum, model)
      }

      object gaussianProcess {
        def apply(x: Any, table: Any, krigingWeight: Any, kernel: FunctionRef) = new FunctionCall("model.reg.gaussianProcess", x, table, krigingWeight, kernel)
      }

      object residual {
        def apply(observation: Any, prediciton: Any) = new FunctionCall("model.reg.residual", observation, prediciton)
      }

      object pull {
        def apply(observation: Any, prediciton: Any, uncertainty: Any) = new FunctionCall("model.reg.pull", observation, prediciton, uncertainty)
      }

      object mahalanobis {
        def apply(observation: Any, prediction: Any, covariance: Any) = new FunctionCall("model.reg.mahalanobis", observation, prediction, covariance)
      }

      object updateChi2 {
        def apply(pull: Any, state: Any) = new FunctionCall("model.reg.updateChi2", pull, state)
      }

      object reducedChi2 {
        def apply(state: Any) = new FunctionCall("model.reg.reducedChi2", state)
      }

      object chi2Prob {
        def apply(state: Any) = new FunctionCall("model.reg.chi2Prob", state)
      }

    }


    object tree {

      object simpleTest {
        def apply(datum: Any, comparison: Any) = new FunctionCall("model.tree.simpleTest", datum, comparison)
      }

      object missingTest {
        def apply(datum: Any, comparison: Any) = new FunctionCall("model.tree.missingTest", datum, comparison)
      }

      object compoundTest {
        def apply(datum: Any, operator: Any, comparisons: Any, test: FunctionRef) = new FunctionCall("model.tree.compoundTest", datum, operator, comparisons, test)
      }

      object surrogateTest {
        def apply(datum: Any, comparisons: Any, missingTest: FunctionRef) = new FunctionCall("model.tree.surrogateTest", datum, comparisons, missingTest)
      }

      object simpleWalk {
        def apply(datum: Any, treeNode: Any, test: FunctionRef) = new FunctionCall("model.tree.simpleWalk", datum, treeNode, test)
      }

      object missingWalk {
        def apply(datum: Any, treeNode: Any, test: FunctionRef) = new FunctionCall("model.tree.missingWalk", datum, treeNode, test)
      }

      object simpleTree {
        def apply(datum: Any, treeNode: Any) = new FunctionCall("model.tree.simpleTree", datum, treeNode)
      }

    }


    object cluster {

      object closest {
        def apply(datum: Any, clusters: Any) = new FunctionCall("model.cluster.closest", datum, clusters)

        def apply(datum: Any, clusters: Any, metric: FunctionRef) = new FunctionCall("model.cluster.closest", datum, clusters, metric)
      }

      object closestN {
        def apply(n: Any, datum: Any, clusters: Any) = new FunctionCall("model.cluster.closestN", n, datum, clusters)

        def apply(n: Any, datum: Any, clusters: Any, metric: FunctionRef) = new FunctionCall("model.cluster.closestN", n, datum, clusters, metric)
      }

      object randomSeeds {
        def apply(data: Any, k: Any, newCluster: FunctionRef) = new FunctionCall("model.cluster.randomSeeds", data, k, newCluster)
      }

      object kmeansIteration {
        def apply(data: Any, clusters: Any, metric: FunctionRef, update: FunctionRef) = new FunctionCall("model.cluster.kmeansIteration", data, clusters, metric, update)
      }

      object updateMean {
        def apply(data: Any, cluster: Any, weight: Any) = new FunctionCall("model.cluster.updateMean", data, cluster, weight)
      }

    }


    object neighbor {

      object mean {
        def apply(points: Any) = new FunctionCall("model.neighbor.mean", points)

        def apply(points: Any, weight: FunctionRef) = new FunctionCall("model.neighbor.mean", points, weight)
      }

      object nearestK {
        def apply(k: Any, datum: Any, codebook: Any, metric: FunctionRef) = new FunctionCall("model.neighbor.nearestK", k, datum, codebook, metric)

        def apply(k: Any, datum: Any, codebook: Any) = new FunctionCall("model.neighbor.nearestK", k, datum, codebook)
      }

      object ballR {
        def apply(r: Any, datum: Any, codebook: Any) = new FunctionCall("model.neighbor.ballR", r, datum, codebook)

        def apply(r: Any, datum: Any, codebook: Any, metric: FunctionRef) = new FunctionCall("model.neighbor.ballR", r, datum, codebook, metric)
      }

    }


    object naive {

      object gaussian {
        def apply(datum: Any, classModel: Any) = new FunctionCall("model.naive.gaussian", datum, classModel)
      }

      object multinomial {
        def apply(datum: Any, classModel: Any) = new FunctionCall("model.naive.multinomial", datum, classModel)
      }

      object bernoulli {
        def apply(datum: Any, classModel: Any) = new FunctionCall("model.naive.bernoulli", datum, classModel)
      }

    }


    object neural {

      object simpleLayers {
        def apply(datum: Any, model: Any, activation: FunctionRef) = new FunctionCall("model.neural.simpleLayers", datum, model, activation)
      }

    }


    object svm {

      object score {
        def apply(datum: Any, model: Any, kernel: FunctionRef) = new FunctionCall("model.svm.score", datum, model, kernel)
      }

    }


  }


}
